<?xml version="1.0" encoding="UTF-8"?><testsuites failures="0" name="dependency-check" tests="76"><testsuite failures="0" id="0" name="/home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar" package="arc-1.13.7.Final.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="1" name="/home/jenkins/.mvnrepository/dk/brics/automaton/automaton/1.11-8/automaton-1.11-8.jar" package="automaton-1.11-8.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="automaton-1.11-8.jar"/></testsuite><testsuite failures="0" id="2" name="/home/jenkins/.mvnrepository/org/checkerframework/checker-qual/2.5.2/checker-qual-2.5.2.jar" package="checker-qual-2.5.2.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="checker-qual-2.5.2.jar"/></testsuite><testsuite failures="0" id="3" name="/home/jenkins/.mvnrepository/org/apache/commons/commons-compress/1.20/commons-compress-1.20.jar" package="commons-compress-1.20.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="commons-compress-1.20.jar"/></testsuite><testsuite failures="0" id="4" name="/home/jenkins/.mvnrepository/com/google/errorprone/error_prone_annotations/2.2.0/error_prone_annotations-2.2.0.jar" package="error_prone_annotations-2.2.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="error_prone_annotations-2.2.0.jar"/></testsuite><testsuite failures="0" id="5" name="/home/jenkins/.mvnrepository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar" package="failureaccess-1.0.1.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="failureaccess-1.0.1.jar"/></testsuite><testsuite failures="0" id="6" name="/home/jenkins/.mvnrepository/com/github/mifmif/generex/1.0.2/generex-1.0.2.jar" package="generex-1.0.2.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="generex-1.0.2.jar"/></testsuite><testsuite failures="0" id="7" name="/home/jenkins/.mvnrepository/org/graalvm/sdk/graal-sdk/21.0.0/graal-sdk-21.0.0.jar" package="graal-sdk-21.0.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="graal-sdk-21.0.0.jar"/></testsuite><testsuite failures="0" id="8" name="/home/jenkins/.mvnrepository/com/google/guava/guava/30.1-jre/guava-30.1-jre.jar" package="guava-30.1-jre.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="guava-30.1-jre.jar"/></testsuite><testsuite failures="0" id="9" name="/home/jenkins/.mvnrepository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar" package="j2objc-annotations-1.3.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="j2objc-annotations-1.3.jar"/></testsuite><testsuite failures="0" id="10" name="/home/jenkins/.mvnrepository/com/fasterxml/jackson/core/jackson-annotations/2.12.0/jackson-annotations-2.12.0.jar" package="jackson-annotations-2.12.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jackson-annotations-2.12.0.jar"/></testsuite><testsuite failures="0" id="11" name="/home/jenkins/.mvnrepository/com/fasterxml/jackson/core/jackson-core/2.12.0/jackson-core-2.12.0.jar" package="jackson-core-2.12.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jackson-core-2.12.0.jar"/></testsuite><testsuite failures="0" id="12" name="/home/jenkins/.mvnrepository/com/fasterxml/jackson/core/jackson-databind/2.12.0/jackson-databind-2.12.0.jar" package="jackson-databind-2.12.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jackson-databind-2.12.0.jar"/></testsuite><testsuite failures="0" id="13" name="/home/jenkins/.mvnrepository/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.12.0/jackson-datatype-jdk8-2.12.0.jar" package="jackson-datatype-jdk8-2.12.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jackson-datatype-jdk8-2.12.0.jar"/></testsuite><testsuite failures="0" id="14" name="/home/jenkins/.mvnrepository/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.12.0/jackson-datatype-jsr310-2.12.0.jar" package="jackson-datatype-jsr310-2.12.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jackson-datatype-jsr310-2.12.0.jar"/></testsuite><testsuite failures="0" id="15" name="/home/jenkins/.mvnrepository/com/fasterxml/jackson/module/jackson-module-parameter-names/2.12.0/jackson-module-parameter-names-2.12.0.jar" package="jackson-module-parameter-names-2.12.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jackson-module-parameter-names-2.12.0.jar"/></testsuite><testsuite failures="0" id="16" name="/home/jenkins/.mvnrepository/jakarta/annotation/jakarta.annotation-api/1.3.5/jakarta.annotation-api-1.3.5.jar" package="jakarta.annotation-api-1.3.5.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jakarta.annotation-api-1.3.5.jar"/></testsuite><testsuite failures="0" id="17" name="/home/jenkins/.mvnrepository/jakarta/el/jakarta.el-api/3.0.3/jakarta.el-api-3.0.3.jar" package="jakarta.el-api-3.0.3.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jakarta.el-api-3.0.3.jar"/></testsuite><testsuite failures="0" id="18" name="/home/jenkins/.mvnrepository/jakarta/enterprise/jakarta.enterprise.cdi-api/2.0.2/jakarta.enterprise.cdi-api-2.0.2.jar" package="jakarta.enterprise.cdi-api-2.0.2.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jakarta.enterprise.cdi-api-2.0.2.jar"/></testsuite><testsuite failures="0" id="19" name="/home/jenkins/.mvnrepository/jakarta/inject/jakarta.inject-api/1.0/jakarta.inject-api-1.0.jar" package="jakarta.inject-api-1.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jakarta.inject-api-1.0.jar"/></testsuite><testsuite failures="0" id="20" name="/home/jenkins/.mvnrepository/jakarta/interceptor/jakarta.interceptor-api/1.2.5/jakarta.interceptor-api-1.2.5.jar" package="jakarta.interceptor-api-1.2.5.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jakarta.interceptor-api-1.2.5.jar"/></testsuite><testsuite failures="0" id="21" name="/home/jenkins/.mvnrepository/jakarta/transaction/jakarta.transaction-api/1.3.3/jakarta.transaction-api-1.3.3.jar" package="jakarta.transaction-api-1.3.3.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jakarta.transaction-api-1.3.3.jar"/></testsuite><testsuite failures="0" id="22" name="/home/jenkins/.mvnrepository/org/jboss/spec/javax/xml/bind/jboss-jaxb-api_2.3_spec/2.0.0.Final/jboss-jaxb-api_2.3_spec-2.0.0.Final.jar" package="jboss-jaxb-api_2.3_spec-2.0.0.Final.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jboss-jaxb-api_2.3_spec-2.0.0.Final.jar"/></testsuite><testsuite failures="0" id="23" name="/home/jenkins/.mvnrepository/org/jboss/logging/jboss-logging/3.4.1.Final/jboss-logging-3.4.1.Final.jar" package="jboss-logging-3.4.1.Final.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jboss-logging-3.4.1.Final.jar"/></testsuite><testsuite failures="0" id="24" name="/home/jenkins/.mvnrepository/org/jboss/logging/jboss-logging-annotations/2.2.0.Final/jboss-logging-annotations-2.2.0.Final.jar" package="jboss-logging-annotations-2.2.0.Final.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jboss-logging-annotations-2.2.0.Final.jar"/></testsuite><testsuite failures="0" id="25" name="/home/jenkins/.mvnrepository/org/jboss/logmanager/jboss-logmanager-embedded/1.0.9/jboss-logmanager-embedded-1.0.9.jar" package="jboss-logmanager-embedded-1.0.9.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jboss-logmanager-embedded-1.0.9.jar"/></testsuite><testsuite failures="0" id="26" name="/home/jenkins/.mvnrepository/org/jboss/threads/jboss-threads/3.2.0.Final/jboss-threads-3.2.0.Final.jar" package="jboss-threads-3.2.0.Final.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jboss-threads-3.2.0.Final.jar"/></testsuite><testsuite failures="0" id="27" name="/home/jenkins/.mvnrepository/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar" package="jsr305-3.0.2.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="jsr305-3.0.2.jar"/></testsuite><testsuite failures="0" id="28" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-client/5.3.1/kubernetes-client-5.3.1.jar" package="kubernetes-client-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-client@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-client/5.3.1/kubernetes-client-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-client@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-client/5.3.1/kubernetes-client-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="29" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-admissionregistration/5.3.1/kubernetes-model-admissionregistration-5.3.1.jar" package="kubernetes-model-admissionregistration-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-admissionregistration@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-admissionregistration/5.3.1/kubernetes-model-admissionregistration-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-admissionregistration@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-admissionregistration/5.3.1/kubernetes-model-admissionregistration-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="30" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-apiextensions/5.3.1/kubernetes-model-apiextensions-5.3.1.jar" package="kubernetes-model-apiextensions-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-apiextensions@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-apiextensions/5.3.1/kubernetes-model-apiextensions-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-apiextensions@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-apiextensions/5.3.1/kubernetes-model-apiextensions-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="31" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-apps/5.3.1/kubernetes-model-apps-5.3.1.jar" package="kubernetes-model-apps-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-apps@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-apps/5.3.1/kubernetes-model-apps-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-apps@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-apps/5.3.1/kubernetes-model-apps-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="32" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-autoscaling/5.3.1/kubernetes-model-autoscaling-5.3.1.jar" package="kubernetes-model-autoscaling-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-autoscaling@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-autoscaling/5.3.1/kubernetes-model-autoscaling-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-autoscaling@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-autoscaling/5.3.1/kubernetes-model-autoscaling-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="33" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-batch/5.3.1/kubernetes-model-batch-5.3.1.jar" package="kubernetes-model-batch-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-batch@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-batch/5.3.1/kubernetes-model-batch-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-batch@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-batch/5.3.1/kubernetes-model-batch-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="34" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-certificates/5.3.1/kubernetes-model-certificates-5.3.1.jar" package="kubernetes-model-certificates-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-certificates@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-certificates/5.3.1/kubernetes-model-certificates-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-certificates@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-certificates/5.3.1/kubernetes-model-certificates-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="35" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-common/5.3.1/kubernetes-model-common-5.3.1.jar" package="kubernetes-model-common-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-common@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-common/5.3.1/kubernetes-model-common-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-common@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-common/5.3.1/kubernetes-model-common-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="36" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-coordination/5.3.1/kubernetes-model-coordination-5.3.1.jar" package="kubernetes-model-coordination-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-coordination@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-coordination/5.3.1/kubernetes-model-coordination-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-coordination@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-coordination/5.3.1/kubernetes-model-coordination-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="37" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-core/5.3.1/kubernetes-model-core-5.3.1.jar" package="kubernetes-model-core-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-core@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-core/5.3.1/kubernetes-model-core-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-core@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-core/5.3.1/kubernetes-model-core-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="38" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-discovery/5.3.1/kubernetes-model-discovery-5.3.1.jar" package="kubernetes-model-discovery-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-discovery@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-discovery/5.3.1/kubernetes-model-discovery-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-discovery@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-discovery/5.3.1/kubernetes-model-discovery-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="39" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-events/5.3.1/kubernetes-model-events-5.3.1.jar" package="kubernetes-model-events-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-events@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-events/5.3.1/kubernetes-model-events-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-events@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-events/5.3.1/kubernetes-model-events-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="40" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-extensions/5.3.1/kubernetes-model-extensions-5.3.1.jar" package="kubernetes-model-extensions-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-extensions@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-extensions/5.3.1/kubernetes-model-extensions-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-extensions@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-extensions/5.3.1/kubernetes-model-extensions-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="41" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-metrics/5.3.1/kubernetes-model-metrics-5.3.1.jar" package="kubernetes-model-metrics-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-metrics@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-metrics/5.3.1/kubernetes-model-metrics-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-metrics@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-metrics/5.3.1/kubernetes-model-metrics-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="42" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-networking/5.3.1/kubernetes-model-networking-5.3.1.jar" package="kubernetes-model-networking-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-networking@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-networking/5.3.1/kubernetes-model-networking-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-networking@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-networking/5.3.1/kubernetes-model-networking-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="43" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-node/5.3.1/kubernetes-model-node-5.3.1.jar" package="kubernetes-model-node-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-node@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-node/5.3.1/kubernetes-model-node-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-node@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-node/5.3.1/kubernetes-model-node-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="44" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-policy/5.3.1/kubernetes-model-policy-5.3.1.jar" package="kubernetes-model-policy-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-policy@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-policy/5.3.1/kubernetes-model-policy-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-policy@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-policy/5.3.1/kubernetes-model-policy-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="45" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-rbac/5.3.1/kubernetes-model-rbac-5.3.1.jar" package="kubernetes-model-rbac-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-rbac@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-rbac/5.3.1/kubernetes-model-rbac-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-rbac@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-rbac/5.3.1/kubernetes-model-rbac-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="46" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-scheduling/5.3.1/kubernetes-model-scheduling-5.3.1.jar" package="kubernetes-model-scheduling-5.3.1.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-scheduling@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-scheduling/5.3.1/kubernetes-model-scheduling-5.3.1.jar</system-err></testcase><testcase classname="CVE-2020-8570" name="pkg:maven/io.fabric8/kubernetes-model-scheduling@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-scheduling/5.3.1/kubernetes-model-scheduling-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="47" name="/home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-storageclass/5.3.1/kubernetes-model-storageclass-5.3.1.jar" package="kubernetes-model-storageclass-5.3.1.jar" skipped="1" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2020-8554" name="pkg:maven/io.fabric8/kubernetes-model-storageclass@5.3.1"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/fabric8/kubernetes-model-storageclass/5.3.1/kubernetes-model-storageclass-5.3.1.jar</system-err></testcase></testsuite><testsuite failures="0" id="48" name="/home/jenkins/.mvnrepository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar" package="listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar"/></testsuite><testsuite failures="0" id="49" name="/home/jenkins/.mvnrepository/com/squareup/okhttp3/logging-interceptor/3.12.1/logging-interceptor-3.12.1.jar" package="logging-interceptor-3.12.1.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="logging-interceptor-3.12.1.jar"/></testsuite><testsuite failures="0" id="50" name="/home/jenkins/.mvnrepository/org/eclipse/microprofile/config/microprofile-config-api/1.4/microprofile-config-api-1.4.jar" package="microprofile-config-api-1.4.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="microprofile-config-api-1.4.jar"/></testsuite><testsuite failures="0" id="51" name="/home/jenkins/.mvnrepository/org/eclipse/microprofile/context-propagation/microprofile-context-propagation-api/1.0.1/microprofile-context-propagation-api-1.0.1.jar" package="microprofile-context-propagation-api-1.0.1.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="microprofile-context-propagation-api-1.0.1.jar"/></testsuite><testsuite failures="0" id="52" name="/home/jenkins/.mvnrepository/com/squareup/okhttp3/okhttp/3.12.1/okhttp-3.12.1.jar" package="okhttp-3.12.1.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="okhttp-3.12.1.jar"/></testsuite><testsuite failures="0" id="53" name="/home/jenkins/.mvnrepository/com/squareup/okio/okio/1.15.0/okio-1.15.0.jar" package="okio-1.15.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="okio-1.15.0.jar"/></testsuite><testsuite failures="0" id="54" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar" package="quarkus-arc-1.13.7.Final.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="55" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar" package="quarkus-bootstrap-runner-1.13.7.Final.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="56" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar" package="quarkus-core-1.13.7.Final.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="57" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar" package="quarkus-development-mode-spi-1.13.7.Final.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="58" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar" package="quarkus-ide-launcher-1.13.7.Final.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="59" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-jackson/1.13.7.Final/quarkus-jackson-1.13.7.Final.jar" package="quarkus-jackson-1.13.7.Final.jar" skipped="2" tests="2" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-jackson@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-jackson/1.13.7.Final/quarkus-jackson-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-jackson@1.13.7.Final"><skipped message="Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-jackson/1.13.7.Final/quarkus-jackson-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="60" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar" package="quarkus-kubernetes-client-1.13.7.Final.jar" skipped="19" tests="19" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2019-11246" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The kubectl cp command allows copying files between containers and the user machine. To copy files from a container, Kubernetes runs tar inside the container to create a tar archive, copies it over the network, and kubectl unpacks it on the users machine. If the tar binary in the container is malicious, it could run any code and output unexpected, malicious results. An attacker could use this to write files to any path on the users machine when kubectl cp is called, limited only by the system permissions of the local user. Kubernetes affected versions include versions prior to 1.12.9, versions prior to 1.13.6, versions prior to 1.14.2, and versions 1.1, 1.2, 1.4, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.10, 1.11.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8555" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kube-controller-manager in versions v1.0-1.14, versions prior to v1.15.12, v1.16.9, v1.17.5, and version v1.18.0 are vulnerable to a Server Side Request Forgery (SSRF) that allows certain authorized users to leak up to 500 bytes of arbitrary information from unprotected endpoints within the master&apos;s host network (such as link-local or loopback services).</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11254" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes API Server component in versions 1.1-1.14, and versions prior to 1.15.10, 1.16.7 and 1.17.3 allows an authorized user who sends malicious YAML payloads to cause the kube-apiserver to consume excessive CPU cycles while parsing YAML.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8554" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11244" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>In Kubernetes v1.8.x-v1.14.x, schema info is cached by kubectl in the location specified by --cache-dir (defaulting to $HOME/.kube/http-cache), written with world-writeable permissions (rw-rw-rw-). If --cache-dir is specified and pointed at a different location accessible to other users/groups, the written files may be modified by other users/groups and disrupt the kubectl invocation.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11249" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The kubectl cp command allows copying files between containers and the user machine. To copy files from a container, Kubernetes runs tar inside the container to create a tar archive, copies it over the network, and kubectl unpacks it on the users machine. If the tar binary in the container is malicious, it could run any code and output unexpected, malicious results. An attacker could use this to write files to any path on the users machine when kubectl cp is called, limited only by the system permissions of the local user. Kubernetes affected versions include versions prior to 1.13.9, versions prior to 1.14.5, versions prior to 1.15.2, and versions 1.1, 1.2, 1.4, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.10, 1.11, 1.12.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8552" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes API server component in versions prior to 1.15.9, 1.16.0-1.16.6, and 1.17.0-1.17.2 has been found to be vulnerable to a denial of service attack via successful API requests.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8563" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>In Kubernetes clusters using VSphere as a cloud provider, with a logging level set to 4 or above, VSphere cloud credentials will be leaked in the cloud controller manager&apos;s log. This affects &lt; v1.19.3.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11247" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kube-apiserver mistakenly allows access to a cluster-scoped custom resource if the request is made as if the resource were namespaced. Authorizations for the resource accessed in this manner are enforced using roles and role bindings within the namespace, meaning that a user with access only to a resource in one namespace could create, view update or delete the cluster-scoped resource (according to their namespace role privileges). Kubernetes affected versions include versions prior to 1.13.9, versions prior to 1.14.5, versions prior to 1.15.2, and versions 1.7, 1.8, 1.9, 1.10, 1.11, 1.12.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11248" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The debugging endpoint /debug/pprof is exposed over the unauthenticated Kubelet healthz port. The go pprof endpoint is exposed over the Kubelet&apos;s healthz port. This debugging endpoint can potentially leak sensitive information such as internal Kubelet memory addresses and configuration, or for limited denial of service. Versions prior to 1.15.0, 1.14.4, 1.13.8, and 1.12.10 are affected. The issue is of medium severity, but not exposed by the default configuration.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2018-1002102" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Improper validation of URL redirection in the Kubernetes API server in versions prior to v1.14.0 allows an attacker-controlled Kubelet to redirect API server requests from streaming endpoints to arbitrary hosts. Impacted API servers will follow the redirect as a GET request with client-certificate credentials for authenticating to the Kubelet.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11252" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kube-controller-manager in versions v1.0-v1.17 is vulnerable to a credential leakage via error messages in mount failure logs and events for AzureFile and CephFS volumes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8559" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kube-apiserver in versions v1.6-v1.15, and versions prior to v1.16.13, v1.17.9 and v1.18.6 are vulnerable to an unvalidated redirect on proxied upgrade requests that could allow an attacker to escalate privileges from a node compromise to a full cluster compromise.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11250" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes client-go library logs request headers at verbosity levels of 7 or higher. This can disclose credentials to unauthorized users via logs or command output. Kubernetes components (such as kube-apiserver) prior to v1.16.0, which make use of basic or bearer token authentication, and run at high verbosity levels, are affected.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8558" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubelet and kube-proxy components in versions 1.1.0-1.16.10, 1.17.0-1.17.6, and 1.18.0-1.18.3 were found to contain a security issue which allows adjacent hosts to reach TCP and UDP services bound to 127.0.0.1 running on the node or in the node&apos;s network namespace. Such a service is generally thought to be reachable only by other processes on the same host, but due to this defeect, could be reachable by other hosts on the same LAN as the node, or by containers running on the same node as the service.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11251" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kubectl cp command in versions 1.1-1.12, and versions prior to 1.13.11, 1.14.7, and 1.15.4 allows a combination of two symlinks provided by tar output of a malicious container to place a file outside of the destination directory specified in the kubectl cp invocation. This could be used to allow an attacker to place a nefarious file using a symlink, outside of the destination tree.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8557" name="pkg:maven/io.quarkus/quarkus-kubernetes-client@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kubelet component in versions 1.1-1.16.12, 1.17.0-1.17.8 and 1.18.0-1.18.5 do not account for disk usage by a pod which writes to its own /etc/hosts file. The /etc/hosts file mounted in a pod by kubelet is not included by the kubelet eviction manager when calculating ephemeral storage usage by a pod. If a pod writes a large amount of data to the /etc/hosts file, it could fill the storage space of the node and cause the node to fail.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client/1.13.7.Final/quarkus-kubernetes-client-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="61" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar" package="quarkus-kubernetes-client-internal-1.13.7.Final.jar" skipped="19" tests="19" timestamp="2021-06-19T11:50:07.539371"><testcase classname="CVE-2019-11246" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The kubectl cp command allows copying files between containers and the user machine. To copy files from a container, Kubernetes runs tar inside the container to create a tar archive, copies it over the network, and kubectl unpacks it on the users machine. If the tar binary in the container is malicious, it could run any code and output unexpected, malicious results. An attacker could use this to write files to any path on the users machine when kubectl cp is called, limited only by the system permissions of the local user. Kubernetes affected versions include versions prior to 1.12.9, versions prior to 1.13.6, versions prior to 1.14.2, and versions 1.1, 1.2, 1.4, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.10, 1.11.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8555" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kube-controller-manager in versions v1.0-1.14, versions prior to v1.15.12, v1.16.9, v1.17.5, and version v1.18.0 are vulnerable to a Server Side Request Forgery (SSRF) that allows certain authorized users to leak up to 500 bytes of arbitrary information from unprotected endpoints within the master&apos;s host network (such as link-local or loopback services).</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11254" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes API Server component in versions 1.1-1.14, and versions prior to 1.15.10, 1.16.7 and 1.17.3 allows an authorized user who sends malicious YAML payloads to cause the kube-apiserver to consume excessive CPU cycles while parsing YAML.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8554" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Kubernetes API server in all versions allow an attacker who is able to create a ClusterIP service and set the spec.externalIPs field, to intercept traffic to that IP address. Additionally, an attacker who is able to patch the status (which is considered a privileged operation and should not typically be granted to users) of a LoadBalancer service can set the status.loadBalancer.ingress.ip to similar effect.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11244" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>In Kubernetes v1.8.x-v1.14.x, schema info is cached by kubectl in the location specified by --cache-dir (defaulting to $HOME/.kube/http-cache), written with world-writeable permissions (rw-rw-rw-). If --cache-dir is specified and pointed at a different location accessible to other users/groups, the written files may be modified by other users/groups and disrupt the kubectl invocation.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11249" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The kubectl cp command allows copying files between containers and the user machine. To copy files from a container, Kubernetes runs tar inside the container to create a tar archive, copies it over the network, and kubectl unpacks it on the users machine. If the tar binary in the container is malicious, it could run any code and output unexpected, malicious results. An attacker could use this to write files to any path on the users machine when kubectl cp is called, limited only by the system permissions of the local user. Kubernetes affected versions include versions prior to 1.13.9, versions prior to 1.14.5, versions prior to 1.15.2, and versions 1.1, 1.2, 1.4, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.10, 1.11, 1.12.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8552" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes API server component in versions prior to 1.15.9, 1.16.0-1.16.6, and 1.17.0-1.17.2 has been found to be vulnerable to a denial of service attack via successful API requests.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8563" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>In Kubernetes clusters using VSphere as a cloud provider, with a logging level set to 4 or above, VSphere cloud credentials will be leaked in the cloud controller manager&apos;s log. This affects &lt; v1.19.3.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11247" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kube-apiserver mistakenly allows access to a cluster-scoped custom resource if the request is made as if the resource were namespaced. Authorizations for the resource accessed in this manner are enforced using roles and role bindings within the namespace, meaning that a user with access only to a resource in one namespace could create, view update or delete the cluster-scoped resource (according to their namespace role privileges). Kubernetes affected versions include versions prior to 1.13.9, versions prior to 1.14.5, versions prior to 1.15.2, and versions 1.7, 1.8, 1.9, 1.10, 1.11, 1.12.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11248" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The debugging endpoint /debug/pprof is exposed over the unauthenticated Kubelet healthz port. The go pprof endpoint is exposed over the Kubelet&apos;s healthz port. This debugging endpoint can potentially leak sensitive information such as internal Kubelet memory addresses and configuration, or for limited denial of service. Versions prior to 1.15.0, 1.14.4, 1.13.8, and 1.12.10 are affected. The issue is of medium severity, but not exposed by the default configuration.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. Not much we can do about this one except for wait for Keycloak 8. We can only update the client if the
        server is updated." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2018-1002102" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>Improper validation of URL redirection in the Kubernetes API server in versions prior to v1.14.0 allows an attacker-controlled Kubelet to redirect API server requests from streaming endpoints to arbitrary hosts. Impacted API servers will follow the redirect as a GET request with client-certificate credentials for authenticating to the Kubelet.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11252" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kube-controller-manager in versions v1.0-v1.17 is vulnerable to a credential leakage via error messages in mount failure logs and events for AzureFile and CephFS volumes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8559" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kube-apiserver in versions v1.6-v1.15, and versions prior to v1.16.13, v1.17.9 and v1.18.6 are vulnerable to an unvalidated redirect on proxied upgrade requests that could allow an attacker to escalate privileges from a node compromise to a full cluster compromise.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11250" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes client-go library logs request headers at verbosity levels of 7 or higher. This can disclose credentials to unauthorized users via logs or command output. Kubernetes components (such as kube-apiserver) prior to v1.16.0, which make use of basic or bearer token authentication, and run at high verbosity levels, are affected.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8558" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubelet and kube-proxy components in versions 1.1.0-1.16.10, 1.17.0-1.17.6, and 1.18.0-1.18.3 were found to contain a security issue which allows adjacent hosts to reach TCP and UDP services bound to 127.0.0.1 running on the node or in the node&apos;s network namespace. Such a service is generally thought to be reachable only by other processes on the same host, but due to this defeect, could be reachable by other hosts on the same LAN as the node, or by containers running on the same node as the service.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2019-11251" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kubectl cp command in versions 1.1-1.12, and versions prior to 1.13.11, 1.14.7, and 1.15.4 allows a combination of two symlinks provided by tar output of a malicious container to place a file outside of the destination directory specified in the kubectl cp invocation. This could be used to allow an attacker to place a nefarious file using a symlink, outside of the destination tree.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2020-8557" name="pkg:maven/io.quarkus/quarkus-kubernetes-client-internal@1.13.7.Final"><skipped message="A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs. A whole lot of false positives based on K8S&apos;s internals that have nothing to do with our CRDs" /><system-out>The Kubernetes kubelet component in versions 1.1-1.16.12, 1.17.0-1.17.8 and 1.18.0-1.18.5 do not account for disk usage by a pod which writes to its own /etc/hosts file. The /etc/hosts file mounted in a pod by kubelet is not included by the kubelet eviction manager when calculating ephemeral storage usage by a pod. If a pod writes a large amount of data to the /etc/hosts file, it could fill the storage space of the node and cause the node to fail.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-kubernetes-client-internal/1.13.7.Final/quarkus-kubernetes-client-internal-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="62" name="/home/jenkins/.mvnrepository/org/slf4j/slf4j-api/1.7.16/slf4j-api-1.7.16.jar" package="slf4j-api-1.7.16.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="slf4j-api-1.7.16.jar"/></testsuite><testsuite failures="0" id="63" name="/home/jenkins/.mvnrepository/org/jboss/slf4j/slf4j-jboss-logmanager/1.1.0.Final/slf4j-jboss-logmanager-1.1.0.Final.jar" package="slf4j-jboss-logmanager-1.1.0.Final.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="slf4j-jboss-logmanager-1.1.0.Final.jar"/></testsuite><testsuite failures="0" id="64" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-annotation/1.5.0/smallrye-common-annotation-1.5.0.jar" package="smallrye-common-annotation-1.5.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-common-annotation-1.5.0.jar"/></testsuite><testsuite failures="0" id="65" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-classloader/1.5.0/smallrye-common-classloader-1.5.0.jar" package="smallrye-common-classloader-1.5.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-common-classloader-1.5.0.jar"/></testsuite><testsuite failures="0" id="66" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-constraint/1.5.0/smallrye-common-constraint-1.5.0.jar" package="smallrye-common-constraint-1.5.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-common-constraint-1.5.0.jar"/></testsuite><testsuite failures="0" id="67" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-expression/1.5.0/smallrye-common-expression-1.5.0.jar" package="smallrye-common-expression-1.5.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-common-expression-1.5.0.jar"/></testsuite><testsuite failures="0" id="68" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-function/1.5.0/smallrye-common-function-1.5.0.jar" package="smallrye-common-function-1.5.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-common-function-1.5.0.jar"/></testsuite><testsuite failures="0" id="69" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-io/1.5.0/smallrye-common-io-1.5.0.jar" package="smallrye-common-io-1.5.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-common-io-1.5.0.jar"/></testsuite><testsuite failures="0" id="70" name="/home/jenkins/.mvnrepository/io/smallrye/config/smallrye-config/1.13.1/smallrye-config-1.13.1.jar" package="smallrye-config-1.13.1.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-config-1.13.1.jar"/></testsuite><testsuite failures="0" id="71" name="/home/jenkins/.mvnrepository/io/smallrye/config/smallrye-config-common/1.13.1/smallrye-config-common-1.13.1.jar" package="smallrye-config-common-1.13.1.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-config-common-1.13.1.jar"/></testsuite><testsuite failures="0" id="72" name="/home/jenkins/.mvnrepository/io/smallrye/config/smallrye-config-source-yaml/1.13.1/smallrye-config-source-yaml-1.13.1.jar" package="smallrye-config-source-yaml-1.13.1.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="smallrye-config-source-yaml-1.13.1.jar"/></testsuite><testsuite failures="0" id="73" name="/home/jenkins/.mvnrepository/org/yaml/snakeyaml/1.27/snakeyaml-1.27.jar" package="snakeyaml-1.27.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="snakeyaml-1.27.jar"/></testsuite><testsuite failures="0" id="74" name="/home/jenkins/.mvnrepository/org/wildfly/common/wildfly-common/1.5.4.Final-format-001/wildfly-common-1.5.4.Final-format-001.jar" package="wildfly-common-1.5.4.Final-format-001.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="wildfly-common-1.5.4.Final-format-001.jar"/></testsuite><testsuite failures="0" id="75" name="/home/jenkins/.mvnrepository/io/fabric8/zjsonpatch/0.3.0/zjsonpatch-0.3.0.jar" package="zjsonpatch-0.3.0.jar" skipped="0" tests="1" timestamp="2021-06-19T11:50:07.539371"><testcase classname="dependency-check" name="zjsonpatch-0.3.0.jar"/></testsuite></testsuites>